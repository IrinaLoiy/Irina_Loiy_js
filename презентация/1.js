// Тип данных Symbol - https://learn.javascript.ru/symbol

// В качестве ключей для свойств объекта могут использоваться только строки или символы.
// «Символ» представляет собой уникальный идентификатор.
// Создаются новые символы с помощью функции Symbol():

let id = Symbol();

// При создании символу можно дать описание (также называемое имя), в основном использующееся для отладки кода:

let id = Symbol("id");

// Символы гарантированно уникальны.

let id1 = Symbol("id");
let id2 = Symbol("id");
alert(id1 == id2); // false

// Свойства, чьи ключи – символы, не перебираются циклом for..in.

// Если мы хотим, чтобы одноимённые символы были равны, то следует использовать глобальный реестр:
// вызов Symbol.for(key) возвращает (или создаёт) глобальный символ с key в качестве имени.
// Многократные вызовы команды Symbol.for с одним и тем же аргументом возвращают один и тот же символ.

// Символы имеют два основных варианта использования:

// «Скрытые» свойства объектов. Если мы хотим добавить свойство в объект, который «принадлежит» другому скрипту или библиотеке,
// мы можем создать символ и использовать его в качестве ключа. Символьное свойство не появится в for..in,
// так что оно не будет нечаянно обработано вместе с другими. Также оно не будет модифицировано прямым обращением,
// так как другой скрипт не знает о нашем символе. Таким образом, свойство будет защищено от случайной перезаписи или использования.
// Так что, используя символьные свойства, мы можем спрятать что-то нужное нам, но что другие видеть не должны.

// Если мы хотим использовать символ при литеральном объявлении объекта {...}, его необходимо заключить в квадратные скобки.
// Вот так:

let id = Symbol("id");

let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};

// Это вызвано тем, что нам нужно использовать значение переменной id в качестве ключа, а не строку «id».
// Свойства, чьи ключи – символы, не перебираются циклом for..in.

// А вот Object.assign, в отличие от цикла for..in, копирует и строковые, и символьные свойства:

let id = Symbol("id");
let user = {
  [id]: 123
};

let clone = Object.assign({}, user);

alert( clone[id] ); // 123

// Итак, как мы видели, обычно все символы уникальны, даже если их имена совпадают. Но иногда мы наоборот хотим, 
// чтобы символы с одинаковыми именами были одной сущностью. Например, разные части нашего приложения хотят получить 
// доступ к символу "id", подразумевая именно одно и то же свойство.

// Для этого существует глобальный реестр символов. Мы можем создавать в нём символы и обращаться к ним позже, и при 
// каждом обращении нам гарантированно будет возвращаться один и тот же символ.

// Для чтения (или, при отсутствии, создания) символа из реестра используется вызов Symbol.for(key).

// Он проверяет глобальный реестр и, при наличии в нём символа с именем key, возвращает его, иначе же создаётся новый 
// символ Symbol(key) и записывается в реестр под ключом key.


читаем символ из глобального реестра и записываем его в переменную
let id = Symbol.for("id"); // если символа не существует, он будет создан

читаем его снова в другую переменную (возможно, из другого места кода)
let idAgain = Symbol.for("id");

проверяем -- это один и тот же символ
alert( id === idAgain ); // true

// Для глобальных символов, кроме Symbol.for(key), который ищет символ по имени, существует обратный метод: 
// Symbol.keyFor(sym), который, наоборот, принимает глобальный символ и возвращает его имя.
// К примеру:

// получаем символ по имени
let sym = Symbol.for("name");
let sym2 = Symbol.for("id");

// получаем имя по символу
alert( Symbol.keyFor(sym) ); // name
alert( Symbol.keyFor(sym2) ); // id
















// Тип данных BigInt - https://habr.com/ru/post/354930/#:~:text=%D0%9D%D0%BE%D0%B2%D0%B8%D0%BD%D0%BA%D0%B0%3A%20BigInt-,BigInt%20%E2%80%94%20%D0%BD%D0%BE%D0%B2%D1%8B%D0%B9%20%D1%87%D0%B8%D1%81%D0%BB%D0%BE%D0%B2%D0%BE%D0%B9%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D0%B9%20%D1%82%D0%B8%D0%BF%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20JavaScript%2C%20%D0%BF%D0%BE%D0%B7%D0%B2%D0%BE%D0%BB%D1%8F%D1%8E%D1%89%D0%B8%D0%B9%20%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%B0%D1%82%D1%8C,%D0%BC%D0%B0%D0%BA%D1%81%D0%B8%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%B1%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D0%B3%D0%BE%20%D1%86%D0%B5%D0%BB%D0%BE%D1%87%D0%B8%D1%81%D0%BB%D0%B5%D0%BD%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%B7%D0%BD%D0%B0%D1%87%D0%B5%D0%BD%D0%B8%D1%8F%20Number%20.

// BigInt — новый числовой примитивный тип данных в JavaScript, позволяющий работать с числами произвольной точности.
// С BigInt вы сможете безопасно хранить и обрабатывать большие целые числа даже за пределами максимального безопасного целочисленного значения Number.

// Большие числовые идентификаторы и высокоточные метки времени не могут быть безопасно представлены типом данных Number в JavaScript.
// Зачастую это приводит к ошибкам и вынуждает разработчиков хранить их как строки. С BigInt эти данные могут быть представлены как числовые значения.
// С BigInt вы сможете безопасно хранить и обрабатывать большие целые числа даже за пределами максимального безопасного целочисленного значения Number.

// Для создания BigInt достаточно добавить суффикс n к литеральной записи целого числа. Например, 123 станет 123n.
// Глобальную функцию BigInt(number) можно использовать для приведения числа к BigInt. Другими словами, BigInt(123) === 123n.
// пример, с умножением двух чисел типа Number:

1234567890123456789 * 123;
→ 151851850485185200000

// Если мы посмотрим на цифры младшего разряда, 9 и 3, можно утверждать, что результат умножения должен заканчиваться на 7 (потому что 9 * 3 === 27).
// Но результат заканчивается набором нулей. Что-то пошло не так. Попробуем еще раз с BigInt:

1234567890123456789n * 123n;
→ 151851850485185185047n

// Так как BigInt является самостоятельным типом данных, число типа BigInt никогда не может быть строго равно числу типа Number (например, 42n !== 42).
// Чтобы сравнить число типа BigInt и число типа Number, преобразуйте один из них в тип другого, прежде чем выполнять сравнение, или
// используйте сравнение с преобразованием типов (==):

42n === BigInt(42);
// → true
42n == 42;
// → true

// При приведении к логическому значению (например, в if, при использовании && или ||, или как результат выражения Boolean(int), и так далее),
// числа типа BigInt ведут себя точно так же, как числа типа Number.

// BigInt поддерживает большинство операторов. Бинарные +, -, * и ** работают как обычно. / и % также работают, округляя результат до целого при необходимости.
// Побитовые операторы |, &, <<, >> и ^ работают с числами типа BigInt аналогично числам типа Number, когда отрицательные числа представлены в двоичном виде
// как дополнительный код.

// Единственным исключением из этого правила являются операторы сравнения, такие как === (обсуждался ранее), < и >=, поскольку они возвращают логические значения, 
// не несущие риска потери точности.

1 + 1n;
// → TypeError
123 < 124n;
// → true

// Существуют две функции, позволяющие ограничивать значения BigInt указанным числом значащих бит,
// рассматривая при этом число либо как знаковое, либо как беззнаковое. BigInt.asIntN(width, value)
// ограничит число value типа BigInt указанным в width числом бит с учётом знака, а BigInt.asUintN(width, value)
// сделает то же самое, рассматривая значение как беззнаковое. Например, если вам необходимы операции на 64-битными числами,
// вы можете использовать эти API, чтобы оставаться в соответствующем диапазоне:

максимально возможное значение типа `BigInt`,
которое может быть представлено как знаковое 64-битное целое число.
const max = 2n ** (64n - 1n) - 1n;
BigInt.asIntN(64, max);
// → 9223372036854775807n
BigInt.asIntN(64, max + 1n);
→ -9223372036854775808n
  ^ значение отрицательное, так как произошло переполнение










// WeakMap и WeakSet - https://learn.javascript.ru/weakmap-weakset
// Обычно свойства объекта, элементы массива или другой структуры данных считаются достижимыми и сохраняются в памяти до тех пор,
// пока эта структура данных содержится в памяти.
// Например, если мы поместим объект в массив, то до тех пор, пока массив существует, объект также будет существовать в памяти, несмотря на то,
// что других ссылок на него нет.

Например:

let john = { name: "John" };

let array = [ john ];

john = null; // перезаписываем ссылку на объект
объект john хранится в массиве, поэтому он не будет удалён сборщиком мусора
мы можем взять его значение как array[0]

// WeakMap – принципиально другая структура в этом аспекте. Она не предотвращает удаление объектов сборщиком мусора, когда эти объекты выступают в качестве ключей.

let weakMap = new WeakMap();

let obj = {};

weakMap.set(obj, "ok"); // работает (объект в качестве ключа)
// нельзя использовать строку в качестве ключа
weakMap.set("test", "Whoops"); // Ошибка, потому что "test" не объект

// Теперь, если мы используем объект в качестве ключа и если больше нет ссылок на этот объект, то он будет удалён из памяти (и из объекта WeakMap) автоматически.

let john = { name: "John" };

let weakMap = new WeakMap();
weakMap.set(john, "...");

john = null; // перезаписываем ссылку на объект

// объект john удалён из памяти!


// WeakMap не поддерживает перебор и методы keys(), values(), entries(), так что нет способа взять все ключи или значения из неё.

// В WeakMap присутствуют только следующие методы:

weakMap.get(key)
weakMap.set(key, value)
weakMap.delete(key)
weakMap.has(key)

// В основном, WeakMap используется в качестве дополнительного хранилища данных.

// Если мы работаем с объектом, который «принадлежит» другому коду, может быть даже сторонней библиотеке,
// и хотим сохранить у себя какие-то данные для него, которые должны существовать лишь пока существует этот объект,
// то WeakMap – как раз то, что нужно.

// Мы кладём эти данные в WeakMap, используя объект как ключ, и когда сборщик мусора удалит объекты из памяти,
// ассоциированные с ними данные тоже автоматически исчезнут.

weakMap.set(john, "секретные документы");
// если john умрёт, "секретные документы" будут автоматически уничтожены

// Другая частая сфера применения – это кеширование, когда результат вызова функции должен где-то запоминаться («кешироваться») для того,
// чтобы дальнейшие её вызовы на том же объекте могли просто брать уже готовый результат, повторно используя его.

// Но если мы будем использовать WeakMap вместо Map, то эта проблема исчезнет: закешированные результаты будут автоматически удалены из памяти сборщиком мусора.

// Коллекция WeakSet ведёт себя похоже:

// Она аналогична Set, но мы можем добавлять в WeakSet только объекты (не примитивные значения).
// Объект присутствует в множестве только до тех пор, пока доступен где-то ещё.
// Как и Set, она поддерживает add, has и delete, но не size, keys() и не является перебираемой.

// Например, мы можем добавлять пользователей в WeakSet для учёта тех, кто посещал наш сайт:

let visitedSet = new WeakSet();

let john = { name: "John" };
let pete = { name: "Pete" };
let mary = { name: "Mary" };

visitedSet.add(john); // John заходил к нам
visitedSet.add(pete); // потом Pete
visitedSet.add(john); // John снова

visitedSet сейчас содержит двух пользователей

// проверим, заходил ли John?
alert(visitedSet.has(john)); // true

// проверим, заходила ли Mary?
alert(visitedSet.has(mary)); // false

john = null;
структура данных visitedSet будет очищена автоматически


// Наиболее значительным ограничением WeakMap и WeakSet является то, что их нельзя перебрать или взять всё содержимое. 
// Это может доставлять неудобства,
// но не мешает WeakMap/WeakSet выполнять их главную задачу – быть дополнительным хранилищем данных для объектов, управляемых 
// из каких-то других мест в коде.
